/*

转换 从不同类型的值生成某种类型的新值。 标准转换 内置于 C++ 语言中，并支持其内置类型，并且可以创建用户定义的转换，以执行用户定义类型之间的转换。

标准转换执行内置类型之间的转换、通过继承相关联的类型的指针或引用之间的转换、与 void 指针的双向转换以及到 null 指针的转换。 有关详细信息，请参阅 标准转换。 用户定义的转换执行用户定义的类型之间的转换，或者执行用户定义的类型和内置类型之间的转换。 可以将它们实现为 转换构造函数或 转换 函数。

转换可以是显式（当程序员通过调用从一个类型转换为另一个类型时，例如强制转换或直接初始化的情况），也可以是隐式（当语言或程序调用其他类型而非程序员给定的类型时）。

在以下情况下尝试隐式转换：

提供给函数的自变量与匹配参数的类型不同。

从函数返回的值与函数返回类型的类型不同。

初始值表达式与其初始化的对象的类型不同。

用于控制条件语句、循环构造或切换的表达式不具有对其进行控制时所需的结果类型。

提供给运算符的操作数与匹配的操作数参数的类型不同。 对于内置运算符，这两个操作数的类型必须相同，并且要转换为可表示它们的常规类型。 有关详细信息，请参阅 标准转换。 对于用户定义的运算符，每个操作数都必须与匹配的操作数参数的类型相同。

当一个标准转换无法完成隐式转换时，编译器可以使用用户定义的转换（可选择随后使用其他标准转换）来完成此操作。

当转换站点提供两个或多个用户定义的用于执行相同转换的转换时，该转换将被视为不明确。 这种不明确性是一个错误，因为编译器无法确定应选择哪一个可用转换。 但若只是定义执行相同转换的多种方式，则它不是一个错误，因为可用的转换集在源代码中的不同位置可能不同，例如，可取决于源文件中所包含的头文件。 只要转换站点只提供一个转换，就不会出现不明确性。 多种方式都会导致出现不明确转换，但最常见的方式如下：

多重继承。 该转换在多个基类中定义。

不明确的函数调用。 该转换定义为目标类型的转换构造函数以及源类型的转换函数。 有关详细信息，请参阅 转换函数。

通常只需通过更全面地限定涉及类型的名称或执行显式强制转换来阐明你的意图，即可解决不明确性。

转换构造函数和转换函数都遵循成员访问控制规则，但仅当可以确定明确的转换时才考虑这些转换的可访问性。 这意味着，即使竞争的转换的访问级别会阻止使用该转换，该转换也可能具有不明确性。 有关成员可访问性详细信息，请参阅 成员访问控制。

explicit 关键字和有关隐式转换的问题
默认情况下，当你创建用户定义的转换时，编译器可使用它来执行隐式转换。 有时这是你需要进行的操作，但另一些时候用于指导编译器进行隐式转换的简单规则会使其接受你不希望接受的代码。

可能导致问题的隐式转换的一个已知示例是转换为 bool 。 由于多种原因，你可能想要创建可在布尔上下文中使用的类类型（例如，以便可用于控制语句或循环）。但是，当编译器执行用户定义的到内置类型的转换时，编译器随后可以应用其他标准 if 转换。 此附加标准转换的目的是允许从 提升到 等操作，但也为不太明显的转换（例如，从 到 ）打开了一个门，该转换允许在从未预期的整数上下文中使用类类型。 short int bool int 此特定问题称为布尔 保险箱问题。 此类问题是 关键字 explicit 可以提供帮助的地方。

explicit 关键字告知编译器指定的转换不能用于执行隐式转换。 如果希望在引入 关键字之前实现隐式转换的语法便利性，必须接受隐式转换有时创建的意外后果，或者使用不太方便的命名转换函数 explicit 作为解决方法。 现在，通过使用 关键字，可以创建方便转换，这些转换只能用于执行显式强制转换或直接初始化，并且不会导致 保险箱 Bool 问题保险箱 explicit 问题。

关键字 explicit 可应用于自 C++98 以来的转换构造函数，以及自 C++11 以来的转换函数。 以下部分包含有关如何使用 关键字 explicit 的更多信息。

*/