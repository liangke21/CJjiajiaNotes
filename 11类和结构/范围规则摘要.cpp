

/*

名称的使用在其范围内必须是明确的（直至确定重载的点）。 如果名称表示一个函数，则该函数的参数的数目和类型必须明确。 如果名称不明确，则应用 成员访问 规则。

构造函数初始值设定项
构造函数初始值设定项 在为其指定的构造函数的最外层块的范围内进行计算。 因此，它们可使用构造函数的参数名。

全局名称
在以下情况下，对象、函数或枚举器的名称为全局名称：在任何函数或类的外部引用该名称或将全局一元范围运算符 (::) 作为其前缀，以及未将该名称与上述任何二元运算符结合使用：

范围解析 (::)

(的 对象和引用的成员选择)

指针 () 的成员选择 ->

限定名称
用于二进制范围解析运算符 (::) 的名称称为“限定名”。 在二进制范围解析运算符后指定的名称必须是在该运算符左侧指定的类的成员或其基类的成员。

在成员选择运算符 (之后指定的名称 。 或 ->) 必须是位于运算符左侧指定的对象的类类型成员或其基类 (es) 成员的成员。 成员选择运算符右侧指定的名称 (->) 也可以是另一个类类型的对象，前提 -> 是左侧是类对象，而类定义 (->) 计算为指向某个其他类类型的指针的重载成员选择运算符。 (在 类成员访问中更详细地讨论了这一设置。 )

编译器将按以下顺序搜索名称，并在找到名称时停止搜索：

如果名称在函数内部使用，则搜索当前块范围；否则搜索全局范围。

由里向外的每个封闭块范围，包括最外面的函数范围（包括函数参数）。

如果名称在成员函数内使用，则在类的范围中搜索名称。

在类的基类中搜索名称。

搜索封闭的嵌套类范围（如果有）及其基项。 搜索继续，直到搜索最外面的封闭类范围。

在全局范围中搜索。

但是，您可对此搜索顺序做如下修改：

在名称前面放置 :: 可强制从全局范围处开始搜索。

前面带有 class 、 struct 和关键字的名称 union 强制编译器仅搜索 class 、 struct 或 union 名称。

范围解析运算符的左侧的名称 (::) 只能是 class 、、 struct namespace 或 union 名称。

如果名称引用非静态成员，但用于静态成员函数，则将生成错误消息。 同样，如果名称引用封闭类中的任何非静态成员，则会生成错误消息，因为封闭的类不具有封闭类 this 指针。

函数参数名
函数定义中的函数参数名被视为位于函数的最外层块的范围内。 因此，它们是本地名称并且将在函数退出时超出范围。

函数声明（原型）中的函数参数名位于声明的局部范围内，并且将在声明结尾处超出范围。

默认参数位于它们作为默认值的参数的范围内，如前面两段中所述。 但是，它们无法访问局部变量或非静态类成员。 默认参数的计算时间是函数调用时，但计算位置是在函数声明的原始范围内。 因此，成员函数的默认参数始终在类范围中计算。

*/