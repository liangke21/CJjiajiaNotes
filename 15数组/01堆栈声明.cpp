#include <iostream>


/*
数组是一系列相同类型的对象，该对象占用一个连续的内存区域。 
传统的 C 样式数组是许多 bug 的源，但仍很常见，尤其是在较旧的代码库中。 
在现代 c + + 中，强烈建议使用本部分中所述的 std：： vector 或 std：： array 而不是 c 样式数组。
这两个标准库类型都将其元素存储为连续的内存块。 
但是，它们提供了更高的类型安全性，并支持保证指向序列内有效位置的迭代器。 
有关详细信息，请参阅 容器。


堆栈声明
在 c + + 数组声明中，数组大小在变量名称之后指定，
而不是在类型名称之后指定为其他某些语言。
下面的示例声明一个在堆栈上分配的1000双精度数组。
元素数必须以整数文本形式提供，或者作为常量表达式提供。 
这是因为编译器必须知道要分配多少堆栈空间;不能使用在运行时计算的值。 
为数组中的每个元素分配默认值0。 如果没有分配默认值，
则每个元素最初都包含在该内存位置发生的任何随机值。
*/



int main0101() {
    constexpr size_t size = 1000;

    // 声明要在堆栈上分配的双精度数组
    constexpr  int size2 = 1000;

    double numbers[size]{ 0 };

    double numbers2[size2]{ 0 };

    // 为第一个元素分配一个新值
    numbers[0] = 1;

    // 为每个后续元素赋值
    // (numbers[1] 是数组中的第二个元素。)
    for (size_t i = 1; i < size; i++)
    {
        numbers[i] = numbers[i - 1] * 1.1;
    }

    // 访问每个元素
    for (size_t i = 0; i < size; i++)
    {
        std::cout << numbers[i] << " ";
    }


    return 0;
}

/*
数组中的第一个元素是第零个元素。 最后一个元素是 (n-1) 元素，
其中 n 是数组可以包含的元素数。 声明中的元素数量必须是整型，
并且必须大于0。 你有责任确保你的程序永远不会将值传递到大于的下标运算符 (size - 1) 。

仅当数组是或中的最后一个字段 structunion ，并且启用了 Microsoft 扩展 (/Za 或 /permissive- 未将其设置) 时，零大小的数组才合法。

基于堆栈的数组的分配和访问速度比基于堆的数组更快。 但是，堆栈空间是有限的。 数组元素的数目不能太大，因为它使用了太多的堆栈内存。 太多多少依赖于你的程序。 可以使用分析工具来确定数组是否太大。
*/