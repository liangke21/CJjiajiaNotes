#include <iostream>
using namespace std;


/*指针是一种类型的变量。 它将对象的地址存储在内存中，并用于访问该对象。 原始指针是一个指针，其生存期不受封装对象（如智能指针）的控制。 可以为原始指针分配另一个非指针变量的地址，也可以为其分配值 "data-linktype =" 相对路径 ">nullptr 。 尚未分配值的指针包含随机数据。

还可以取消 引用 指针以检索它指向的对象的值。 成员访问运算符提供对象成员的访问权限。*/
int main01010101() {

    int* p = nullptr; // 声明指针并初始化它
                          // 这样它就不会存储随机地址
    cout << &p << endl;
    int i = 5;
    p = &i; // 分配指向对象地址的指针
    cout << &p << endl;


    int j = *p; // 取消引用 p 以检索其地址处的值
    cout << &j << endl;
    return 0;
}
/*
指针可指向类型化对象或 void 。 当程序在内存中的 堆 上分配对象时，
它将以指针的形式接收该对象的地址。 此类指针称为 拥有指针。 
如果不再需要堆分配的对象，则必须使用拥有指针 (或其副本) 的副本。 
未能释放内存会导致 内存泄漏，并将该内存位置呈现给计算机上的任何其他程序不可用。
new必须使用 delete (或new) 释放已分配的内存。 
有关详细信息，请参阅 new -and- delete -operators "linktype =" 相对路径 ">new 和 delete 运算符 。



*/


//MyClass* mc = new MyClass(); // 在堆上分配对象
//mc->print(); // 访问类成员
//delete mc; // 删除对象（请不要忘记！）

/*
如果未将指针声明为) ，则该指针 (const 可以递增或递减，使其在内存中的另一个位置递增或递减。 
此操作称为 指针算法。 C 样式编程中使用它来循环访问数组或其他数据结构中的元素。 
const指针不能指向不同的内存位置，在这种情况下，与const类似。 有关详细信息，
请参阅 const 和 volatile 指针 "linktype =" 相对路径 ">const 和可变指针 。


*/


int main010101() {


    // 声明一个 C 风格的字符串。编译器添加终止 &#39;\0&#39;.
    const char* str = "Hello world";

    const int c = 1;
    const int* pconst = &c; // 声明一个指向 const int 的非常量指针
    const int c2 = 2;
    pconst = &c2;  // OK pconst 本身不是 const
    const int* const pconst2 = &c;
    // pconst2 = &c2; //错误！ pconst2 是常量。

    return 0;
}

/*
在64位操作系统上，指针的大小为64位。 系统的指针大小决定了可以有多少可寻址内存。 指针指向同一内存位置的所有副本。 在 c + + 中广泛使用指针 (和引用) ，以便向函数和函数传递更大的对象。 这是因为复制对象的地址比复制整个对象通常更有效。 在定义函数时，将指针参数指定为， const 除非您想要函数修改对象。 通常， const 引用是将对象传递到函数的首选方式，除非对象的值可能是 nullptr 。

指向函数的指针使函数能够传递到其他函数，并用于 C 样式编程中的 "回调"。 现代 c + + 使用 lambda 表达式 来实现此目的。
*/